# Report7



## Q1

Briefly describe the FIFO page-replacement algorithm and analyze its algorithm complexity

>   1.  FIFO算法：当有新的查询到来时，先检查目标页表是否已在内存中，如果在则直接返回结果，如果不在，若队列已满移出队列首部的页表，将新页表调入队尾并返回结果，若队列未满，则只将新页表调入队尾并返回结果。
>
>   2.  算法复杂度：根据使用的数据结构不同而不同；
>       缓存大小（最多可缓存的页表数量）为 k，页表查询次数为 n；
>
>   如果只使用双向链表（或者环形队列）实现算法，每次从链表中查询目标页表是否在内存中的时间复杂度为 O(k) ，插入新页表和移除旧页表的时间复杂度均为 O(1) ，每次页表请求的时间复杂度为 O(k)，整个算法时间复杂度为 O(nk)；
>
>   如果使用双向链表（或者环形队列）和hashmap（ 或者set，存储在内存中的页表的信息）实现算法，查询的时间复杂度变为O(1) ，每次页表请求的时间复杂度为 O(1)，整个算法时间复杂度为 O(n) 。




## Q2

Briefly describe the MIN page-replacement algorithm and analyze its algorithm complexity

>   1.  MIN算法: 
>
>   实现一：当有新的查询到来时，先检查目标页表是否已在内存中，如果在则直接返回结果，如果不在，若队列已满，在未处理的页表请求中找出 最长时间不会使用 的页表，用新页表替换它并返回新页表，若队列未满，则只将新页表放入内存并返回结果。
>
>   实现二：基本与实现一相同，不同的是找出 最长时间不会使用的页表 的方式：首先对所有页表请求进行预处理，对于每个不同的请求，用队列保存它每次请求的时间，队首一直是下一次请求的时间（具体实现上，这些队列的元素不一定是一开始全部入队）；将在内存中的页表的队列维护成按照 下次使用时间降序 的有序队列，找出 最长时间不会使用的页表 直接从有序队列首部取出。
>
>   2.  算法复杂度： 根据实现方式不同而不同；
>       缓存大小（最多可缓存的页表数量）为 k，页表查询次数为 n；
>
>   
>
>   实现一： 检查目标页表是否已在内存中的时间复杂度是 O(1) （不使用hashmap） 或者 O(k) （使用hashmap），遍历未来数据找出在内存中的页表中最长时间不会使用的页表，时间复杂度是 O(n)，每次页表请求的时间复杂度为 O(n)，整个算法时间复杂度为 O(n^2) ；
>
>   实现二： 检查目标页表是否已在内存中的时间复杂度是 O(1) （不使用hashmap） 或者 O(k) （使用hashmap），预处理的时间复杂度为 O(n)，维护按照 下次使用时间降序 的有序队列的时间复杂度为 O(k) （普通队列） 或者 O(logk) （二叉大顶堆），每次页表请求的时间复杂度为 O(k)，整个算法时间复杂度为 O(nk) 。



## Q3

Briefly describe the LRU page-replacement algorithm and analyze its algorithm complexity

>   1.  LRU算法: 
>       实现一：当有新的查询到来时，先检查目标页是否已在内存中，如果在则直接返回结果，如果不在，若队列已满用新页置换 最长时间没有使用 的页并返回结果，若队列未满，则只将新页放入内存并返回结果。
>
>       实现二：当有新的查询到来时，先检查目标页是否已在内存中，如果在则更新该页最后访问时间然后返回结果，如果不在，若队列已满用新页置换 最长时间没有使用 的页（通过在缓存中的页的最后访问时间判断）并更新新页最后访问时间然后返回结果，若队列未满，则只将新页放入内存并返回结果。
>
>       实现三： 当有新的查询到来时，先检查目标页是否已在内存中，如果在则将该页挪到链表前面并返回，如果不在，若链表已满移出链表尾部的页，将新页放到链表前面并返回，若链表未满，则只将新页放到链表前面并返回。
>
>   2.  算法复杂度： 根据使用的数据结构不同而不同；
>       缓存大小（最多可缓存的页表数量）为 k，页表查询次数为 n；
>
>       实现一：每次需要变量历史数据检查内存中的页中最长时间没有使用的页，算法时间复杂度为 O(n)，每次页表请求的时间复杂度为 O(n)，整个算法时间复杂度为 O(n^2) ；
>
>       实现二：在缓存的页中寻找最长时间没有使用的页， 算法时间复杂度为 O(k)， 每次页表请求的时间复杂度为 O(n)，整个算法时间复杂度为 O(nk) ；
>
>       实现三：每次页表请求的时间复杂度为 O(1)，整个算法时间复杂度为 O(n) ；



## Q4

Briefly describe the clock algorithm and analyze its algorithm complexity

>   1.  clock算法： clock算法的一种方式是采用循环队列，队列每一项存着页信息和一个引用计数（初始化为N），指针(即时钟指针)指示接下来要置换哪个页面。当有新的查询到来时，检查目标页是否已在内存中，如果在则直接返回结果，如果不在，时钟指针向前移动直到找到一个引用计数为 0 的页（在向前移动的同时，它会将引用计数减一），并用新页替换该页。 
>   2.  算法复杂度： 缓存大小（最多可缓存的页表数量）为 k，页表查询次数为 n；clock算法需要找到引用计数为 0 的页，时间复杂度为 O(k)，每次页表请求的时间复杂度为 O(k)，整个算法时间复杂度为 O(nk) ；



## Q5

完成代码作业并回答hit rate:

1.in: FIFO:\_\_\_\_ % MIN:\_\_\_\_ % LRU:\_\_\_\_ % CLOCK:\_\_\_\_ %

2.in: FIFO:\_\_\_\_ %  MIN:\_\_\_\_ % LRU:\_\_\_\_ % CLOCK:\_\_\_\_ %

3.in: FIFO:\_\_\_\_ %  MIN:\_\_\_\_ % LRU:\_\_\_\_ % CLOCK:\_\_\_\_ % 

>   | TEST | FIFO  | MIN   | LRU   | CLOCK |
>   | ---- | ----- | ----- | ----- | ----- |
>   | 1.in | 11.98 | 42.40 | 11.76 | 11.93 |
>   | 2.in | 11.85 | 43.27 | 11.85 | 11.83 |
>   | 3.in | 82.36 | 88.58 | 82.39 | 82.38 |

